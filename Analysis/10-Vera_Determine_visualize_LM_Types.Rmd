---
  title: "Extracting landmark curves and patches; processing into 3D surfslide and curvslides"
author: "Vera Weisbecker"
date: "`r Sys.Date()`"
output:
  html_document:
  fig_width: 12
fig_height: 6
---

```{r}
library(stringr)
library(geomorph)

#loading the below loads objects called land_data, NOT "wombat"
load("../Data/Processed/wombat.Rda")
AllWombats<-land_data
load("../Data/Processed/wombat_krefftii.Rda")
NHNW<-land_data
load("../Data/Processed/wombat_latifrons.Rda")
SHNW<-land_data
load("../Data/Processed/wombat_ursinus.Rda")
CW<-land_data


#read classifiers
cranium<-read.csv("../Data/Raw/classifier_cranium_wombat.csv")
mandible<-read.csv("../Data/Raw/classifier_mandible_wombat.csv")
```
# Load data. These need to be raw data so I can pull out the landmark names
```{r}
  ## Create vectors of patch points, semi-landmarks, and landmarks
  # LM point name metadata
  
#change "cranium" designations to "mandible" designations as needed

rawdata_cranium_wombat<-read.csv ("../Data/Raw/landmarkdata_cranium_wombat.csv")

pt_names <-rawdata_cranium_wombat[, 1] # grabs first column of raw coords
foo2 <- str_sub(pt_names, 3, -1) # gets rid of X, Y, Z designations
u_pt_names <- unique(foo2)

patches <- str_detect(u_pt_names, "patch") # check to see what Cruise called these points
pat_num <- which(patches == TRUE)

sliders <- str_detect(u_pt_names, "CUR")
sli_num <- which(sliders == TRUE)

LM <- !(sliders | patches)
LM_num <- which(LM == TRUE)

#Assign each landmark the appropriate number; Fixed is 1, semis are 2, patches are 3

#you need a 2-column matrix with column 1 the landmark number and column 2 available for filling (I am using a file that has some numbers already)
landmarkgroups=read.csv("../Data/Raw/landmarkgroups_cranium_wombat.csv")

landmark_LM_types<-landmarkgroups
for (i in 1:length(landmark_LM_types[,1])){
if(landmark_LM_types[i,1] %in% pat_num ==TRUE)
landmark_LM_types[i,2]<-3

else
  
if(landmark_LM_types[i,1] %in% sli_num ==TRUE)
landmark_LM_types[i,2]<-2 

else
  
if(landmark_LM_types[i,1] %in% LM_num ==TRUE)
landmark_LM_types[i,2]<-1   

}

#create Surfslide file
  surfslide_cranium_wombat=which(landmark_LM_types$x==3)
  write.csv(surfslide_cranium_wombat, file="../Data/Raw/surfslide_cranium_wombat.csv")

#curveslide file created manually using the visualization code below and the Viewbox landmark names contained in the landmarkdata_cranium_wombat raw data file.

# Checking that the sliding semilandmarks were correctly chosen
curves_cranium_wombat=which(landmark_LM_types$x==2)
curveslide=read.csv(file="../Data/Raw/curveslide_cranium_wombat.csv")

#check that the sliding lms as designated in viewbox match with the lms designated in the curveslide file; because the curveslide file needs to be done manually, this is an important step
setdiff(curveslide$slider, curves_cranium_wombat)
setdiff(curves_cranium_wombat, curveslide$slider)

``` 
  

###visualize curves

```{r}

# import raw data for visualizing curves
# Transpose rows and columns because of the format that Viewbox exports in
Wom_cranium_Data <- t(rawdata_cranium_wombat) 
# Remove any empty rows
Wom_cranium_Data <- Wom_cranium_Data[complete.cases(Wom_cranium_Data),] 
# Make 3D Array
Wom_cranium_Data <- arrayspecs(Wom_cranium_Data, k=3, p=ncol(Wom_cranium_Data)/3) 

Wom_cranium_Ref <- Wom_cranium_Data[,,6]



PartLevels= unique(landmark_LM_types[,2])
Colours<-rainbow(length(PartLevels))
Colours <- c("blue", "orange")

Part=list()
#Subsetting the partition levels
for(i in 1:length(PartLevels)){
  Part[[i]]<-which (landmark_LM_types[,2] == PartLevels[[i]])
} 

#plotting the spheres- if you get only white, increase the radius!!       
open3d()
for (i in 1:length(PartLevels)){
  spheres3d(WomMaRef[Part[[i]],1], WomMaRef[Part[[i]],2], WomMaRef[Part[[i]],3], col=Colours[i], lit=TRUE,radius = 0.4, asp=F)
  
}

#Add text to see which LM number is a curve/fixed LM/ patch; Viewbox is really chaotic in the order of curve points!
text3d(WomMaRef, text=c(1:826), adj=1.2, cex=0.8)


```
